# 既存システムプロファイル作成プロンプト

## 概要

既存システムのドキュメント（ヘルプページ、API仕様書、コード等）から、
改修設計に必要な情報だけを凝縮した **「システムプロファイル」** を作成するためのプロンプトです。

既存の情報をそのまま全部渡すとトークンが膨大になるため、
このプロンプトで **改修設計に必要な構造化サマリー** を先に作っておき、
[existing-system-design-prompt.md](existing-system-design-prompt.md) の入力素材として使います。

**入力**: 既存システムの情報（以下のいずれか、または組み合わせ）
- ユーザー向けヘルプページ / 操作マニュアル（Markdown、HTML等）
- API仕様書（OpenAPI、Swagger等）
- ソースコード（主要クラス、設定ファイル等）
- ER図、アーキテクチャ図
- 既存の設計書（あれば）

**出力**: システムプロファイル（Markdown、目標 10000〜20000トークン）

## 使い方

### 基本フロー

1. プロンプト内の **「事前記入欄」** を埋める（システム名、技術スタック、提供資料の種類等）
2. 既存システムの資料を添付する
3. プロンプトを実行してシステムプロファイルを生成する
4. 生成されたプロファイルを保存しておく（改修のたびに再利用）

```
[事前記入欄を記入] + [既存ドキュメント/コード]
    ↓ このプロンプト（1回目）
[システムプロファイル] ← 保存しておく（改修のたびに再利用）
    ↓ existing-system-design-prompt.md（2回目）
[改修向け技術設計書]
    ↓ technical-design-to-pbi-prompt.md（3回目）
[PBI / GitHub Issue]
```

### 入力が大きい場合

ドキュメントが1回で渡せない場合は、分割して渡してください。

1. **1回目**: 「以下はシステムのヘルプページです。まだ続きがあるので、読み込んだら"OK"とだけ答えてください」
2. **2〜N回目**: 残りのドキュメントを同様に渡す
3. **最終回**: このプロンプトを渡して、システムプロファイルを生成させる

### プロファイルの更新

システムプロファイルは一度作ったら保存しておき、改修のたびに再利用できます。
システムに大きな変更（新機能追加、アーキテクチャ変更等）があった場合のみ更新してください。

更新時は、既存プロファイルと差分情報を渡して「このプロファイルを更新してください」と指示します。

---

## プロンプト

以下をコピーしてそのまま使用してください。

```
あなたは、既存システムの改修設計を支援する熟練のソフトウェアアーキテクトです。

添付した既存システムの情報（ヘルプページ、API仕様書、コード、設計書等）を読み込み、
今後の改修設計で繰り返し使える **「システムプロファイル」** を作成してください。

---

## 事前記入欄（人間が記入してからプロンプトを実行してください）

### システム名・概要
* システム名: （例: 〇〇管理システム）
* 一言で言うと: （例: 飲食店向けの予約・顧客管理SaaS）

### 提供する資料
以下のうち、今回添付する資料にチェックを入れてください。
- [ ] ユーザー向けヘルプページ / 操作マニュアル
- [ ] API仕様書（OpenAPI、Swagger等）
- [ ] ソースコード（主要クラス、設定ファイル等）
- [ ] ER図 / アーキテクチャ図
- [ ] 既存の設計書
- [ ] その他:

### 技術スタック（分かる範囲で）
* 言語: （例: Kotlin 1.9）
* フレームワーク: （例: Spring Boot 3.2）
* DB: （例: PostgreSQL 16）
* インフラ: （例: AWS ECS Fargate）
* その他: （例: Redis、Elasticsearch等）

### アーキテクチャパターン
（例: モノリス / マイクロサービス / モジュラーモノリス。不明なら空欄でOK）

### 特に重視してほしい領域
改修予定や関心のある領域があれば記載してください。該当セクションがより詳細に出力されます。
（例: 決済周りの改修を予定しているので、決済連携とトランザクション管理を重点的に。空欄でもOK）

### ドキュメントに載っていない既知の注意点
資料からは読み取れないが、プロファイルに含めたい情報があれば記載してください。
（例: 認証は自社実装からAuth0に移行中。旧APIは/api/v1に残っているが新規では使わない。空欄でもOK）

---

## 目的

このプロファイルは、改修の技術設計書を作成する際の入力素材として使います。
既存システムの全情報をその都度渡す代わりに、このプロファイルだけで
「既存システムがどういう作りか」を把握できることが目標です。

## 制約事項

* **事前記入欄の情報を最優先の事実として扱ってください。** 添付資料と矛盾する場合は `[矛盾]` マーカーを付けて両方記載してください。
* 「特に重視してほしい領域」が記載されている場合、該当セクションはより詳細に（具体例や実装パターンを多めに）記載してください。
* 出力はMarkdown形式で、**10000〜20000トークン** を目安にしてください。
  必要な情報が多い場合は超えても構いません。逆に小規模なシステムの場合は短くて構いません。
* 事実のみを記載し、推測は `[推測]` マーカーを付けてください。
* 改修設計に不要な業務の詳細（画面の細かい操作手順等）は省略してください。
* 情報が読み取れなかった項目は「不明」と記載し、確認方法があれば併記してください。
* APIの規約やエラーハンドリングパターンには **具体例（リクエスト/レスポンスのサンプル）** を含めてください。

---

## 出力フォーマット

### 1. システム概要
* システム名と目的（1〜2文）
* 主要なユーザー種別と利用シーン
* システムの規模感（概算のテーブル数、API数、画面数）

### 2. 技術スタック
| レイヤー | 技術 | バージョン |
|---------|------|-----------|
| 言語 | | |
| フレームワーク | | |
| DB | | |
| インフラ | | |
| 認証 | | |
| CI/CD | | |
| 監視 | | |

### 3. アーキテクチャ
* パターン: （モノリス / マイクロサービス / モジュラーモノリス等）
* レイヤー構成: （Controller → Service → Repository等）
* 主要モジュール/サービスの一覧と責務（箇条書き、各1行）

### 4. API規約

以下を **具体的なサンプル付き** で記載してください。

* ベースURL / バージョニング方式
* 認証方式（Bearer Token / Session / API Key等）
  - ヘッダーの具体例: `Authorization: Bearer xxx` 等
* リクエストの共通フォーマット
  - 典型的なリクエスト例（1つ）
* レスポンスの共通フォーマット
  - 成功時の典型例（1つ）
  - エラー時の典型例（1つ。エラーコード体系も含む）
* ページネーション方式（使用している場合）
  - パラメータ例: `?page=1&per_page=20` 等
* レート制限（使用している場合）
* 命名規則
  - パス: `/api/v1/user-profiles` (kebab-case) 等
  - リクエスト/レスポンスフィールド: `userName` (camelCase) 等
* HTTPステータスコードの使い分け方針

### 5. データベース設計パターン

**全テーブルの定義を列挙する必要はありません。**
このシステムのDBが「どういうルールで設計されているか」のパターンを記載してください。
改修対象の具体的なテーブルは、改修設計時に別途確認します。

#### 5.1 設計規約
* テーブル命名規則（複数形/単数形、snake_case等）
* カラム命名規則（snake_case等、略称の使い方）
* 主キー戦略（auto-increment / UUID / ULID等）
* 外部キー制約の方針（物理制約あり/アプリ側のみ）
* 論理削除/物理削除の方針（deleted_at / is_deleted / 物理削除等）

#### 5.2 共通パターン
* 共通カラム（全テーブルに存在するカラム）
  - 例: `id`, `created_at`, `updated_at`, `deleted_at`, `created_by` 等
* ステータス/区分値の管理方式（integer型コード / enum / マスタテーブル参照）
* 履歴テーブルの方式（あれば: `_histories` テーブル、イベントソーシング等）
* 多対多リレーションの方式（中間テーブルの命名規則等）
* マルチテナント方式（該当する場合: スキーマ分離 / テナントIDカラム等）

#### 5.3 規模感
* テーブル総数の概算
* 主要テーブルの行数の規模感（千件/万件/百万件/億件オーダー）
* データ量が特に多いテーブル（あれば）

#### 5.4 主要エンティティの関係（概要のみ）
* MermaidのerDiagramで **中核エンティティ（5〜10個程度）** の関係のみ図示
* 全テーブルを載せない。システムの骨格となるエンティティのみ

```mermaid
erDiagram
    %% 中核エンティティの関係のみ（5〜10個程度）
```

### 6. 認証・認可モデル
* 認証フロー（ログイン → トークン発行 → リクエスト認証の流れ）
* 認可モデル（RBAC / ABAC等）
* ロール一覧と主な権限（テーブル形式）
* セッション/トークン管理方式

### 7. 主要ビジネスフロー
システムの核となるビジネスフローを **最大5つ** 選び、
各フローを1〜3行で要約してください。

| フロー名 | 概要 | 関連モジュール |
|---------|------|--------------|
| | | |

### 8. バックグラウンド処理・連携基盤

改修時に影響を受けやすいシステム横断的な仕組みを記載してください。

#### 8.1 バッチ処理/定期ジョブ
* 主要なバッチ処理の一覧（ジョブ名、実行タイミング、概要）
* バッチ処理フレームワーク（Sidekiq、Spring Batch、cron等）

#### 8.2 通知/メール送信
* 通知手段（メール、Push通知、SMS、Slack等）
* 通知基盤（SendGrid、SES、Firebase Cloud Messaging等）
* トリガーの仕組み（同期/非同期、イベント駆動等）

#### 8.3 外部サービス連携
* 連携先の外部サービス一覧と用途（決済、認証、ファイルストレージ等）
* 連携方式（REST API、Webhook、SDK等）

### 9. セキュリティ基盤

#### 9.1 暗号化
* 通信時暗号化（TLSバージョン等）
* 保存時暗号化（対象データ、暗号化方式、鍵管理の方針）

#### 9.2 セキュリティテスト
* 使用ツール（SAST: SonarQube等 / SCA: Dependabot等 / DAST: OWASP ZAP等）
* CI/CDパイプラインでの実行タイミング

#### 9.3 監査ログ
* 監査対象の操作（ログイン、データ変更、管理操作等）
* 監査ログの保存先と保存期間
* ログフォーマット

#### 9.4 データ保持/パージポリシー
* データの保持期間ルール（ユーザーデータ、ログ、一時データ等）
* パージ/アーカイブの仕組み（自動/手動、タイミング）

### 10. 非機能特性
* パフォーマンス: 既知のSLO/レスポンスタイム目標（あれば）
* スケーラビリティ: 現在のデータ量・リクエスト量の規模感
* 監視: 使用ツール、主要なアラート条件、ダッシュボード構成
* デプロイ: デプロイ頻度、手順の概要（CI/CDパイプラインの流れ）
* バックアップ: 方式と頻度

### 11. コード規約・パターン

#### 11.1 ディレクトリ構成
主要ディレクトリとその役割をツリー形式で記載してください。
```
src/
├── controllers/    # リクエストハンドリング
├── services/       # ビジネスロジック
├── repositories/   # データアクセス
├── models/         # データモデル
├── ...
```

#### 11.2 命名規則
* クラス名: PascalCase等
* メソッド名: camelCase等
* テーブル名/カラム名: snake_case等
* 定数: UPPER_SNAKE_CASE等

#### 11.3 共通パターン
* エラーハンドリング: 例外クラスの階層、エラーコード体系
  - 具体例: `throw new BusinessException(ErrorCode.COUPON_EXPIRED)` 等
* トランザクション管理: 楽観的ロック/悲観的ロック、アノテーション/デコレータ等
* 冪等性の担保方式: リクエストIDによる重複排除、DBユニーク制約等
* バリデーション: どこで実施するか（Controller / Service / DTO等）
* ログ出力: ログレベルの使い分け、構造化ログの有無
* 非同期処理: キューイング、イベント駆動の有無と方式

#### 11.4 テスト
* テストフレームワーク
* テストディレクトリ構造
* テストデータの管理方法（Factory、Fixture、Seed等）
* カバレッジの現状（わかる範囲で）

### 12. 既知の制約・技術的負債
* パフォーマンス上の既知の課題
* アーキテクチャ上の制約や負債
* 非推奨（deprecated）だが残っている仕組み
* 改修時に注意が必要な既知の地雷

---

## 情報が不足している場合

読み取れなかったセクションについては、以下のフォーマットで記載してください:

> **[不明]** このセクションの情報は添付資料から読み取れませんでした。
> 確認方法: [具体的な確認手順。例: `config/database.yml` を確認、インフラチームに問い合わせ等]

## 補足指示

* 情報源が複数ある場合（ヘルプページとコード等）、矛盾する箇所は `[矛盾]` マーカーを付けて両方の記述を残してください。
* ヘルプページからは「ユーザーから見た機能」を、コードからは「技術的な実装」を読み取り、両面から記述してください。
* 情報が十分に読み取れるセクションは具体例を含めて詳しく記載してください。
  情報が薄いセクションは無理に膨らませず、「不明」として確認方法を記載してください。
```

---

## 改修設計への接続

システムプロファイルを作成したら、以下の手順で改修設計に進みます:

1. 新しいチャットを開く
2. 作成したシステムプロファイルを貼り付ける
3. 改修の要求仕様書を添付する
4. [existing-system-design-prompt.md](existing-system-design-prompt.md) のプロンプトを貼り付ける

これにより、既存システムの全ドキュメントを毎回渡す必要がなくなります。

### NotebookLMの場合

NotebookLMを使う場合は、システムプロファイルをソースとして追加しておくと便利です。
改修のたびに要求仕様書だけ追加すれば、プロファイルの情報と組み合わせて設計書を生成できます。
