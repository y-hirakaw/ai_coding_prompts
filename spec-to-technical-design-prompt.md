# ビジネス要求から技術設計書への変換プロンプト

## 概要

要求仕様書（Googleドキュメント等）を、開発エンジニアが実装タスク（GitHub Issue / PBI）に分解できるレベルの「技術設計資料」に変換するためのプロンプトです。

**入力**: ビジネス要求・要求仕様書（Googleドキュメント、PDF等）
**出力**: 技術設計書（Markdown + Mermaid図）

## 使い方

1. Gemini / NotebookLM / Claude のチャット欄に、要求仕様ドキュメントを添付
2. 以下のプロンプトをコピー＆ペースト
3. 出力をレビューし、対話で修正を繰り返す

### ツールの使い分け

| ツール | メリット | コツ |
|--------|---------|------|
| **Gemini (Advanced以上)** | 推論能力が高く、ドキュメントに書いてないことを技術的常識で補完する能力に長ける | 出力されたMermaidコードをNotionやGitHubで確認しながら、対話で修正していく |
| **NotebookLM** | ドキュメントに書かれていることへの忠実度が高く、ハルシネーションが少ない | セクションごとに分割して指示する（「まずデータモデルだけ作って」等） |
| **Claude** | 長文の構造化と論理的な整合性チェックに強い | 一度に全セクション出力可能。フォローアップで深掘り |

---

## プロンプト

以下をコピーしてそのまま使用してください。

```
あなたは、ドメイン駆動設計（DDD）に精通した熟練のソフトウェアアーキテクト兼テックリードです。
加えて、非機能要件設計、セキュリティ設計、および運用設計にも精通しています。

添付した「要求仕様書」を読み込み、開発エンジニアが実装タスク（GitHub Issue/PBI）に
分解できるレベルの「技術設計資料」を作成してください。

## 制約事項

* 出力はMarkdown形式とし、図解が必要な箇所は **Mermaid記法** で記述してください。
* ビジネス用語の曖昧さを排除し、技術的な定義（型、構造、振る舞い）に落とし込んでください。
* ドキュメントに記載がないが、エンジニア視点で明らかに不足している要素は、
  あなたの推論で補完し、 `[推論補完]` と注記してください。
* 「確認済み要件」と「推論による補完」が明確に区別できるようにしてください。
* 複数の実装アプローチが考えられる箇所では、選択肢とトレードオフを提示してください。
* 「未決事項」セクションの質問は、非技術者（プロダクトオーナー等）が読んで回答できる
  平易な日本語で記述してください。技術的選択肢がある場合は、各選択肢のビジネス上の影響
  （コスト、スケジュール、ユーザー体験）を併記してください。

---

## 出力セクション

### 1. ユビキタス言語（用語定義）

ドキュメント内で使われている重要なビジネス用語と、コード上で扱う際の英語名の対応表を作成してください。

* 形式: `日本語名 (EnglishName): 定義`
* 各用語がどの **境界づけられたコンテキスト（Bounded Context）** に属するかを明記
* 同じ用語が異なるコンテキストで別の意味を持つ場合は、その違いを注記

**出力例:**
| 日本語名 | 英語名（コード上） | 定義 | 境界コンテキスト |
|----------|-------------------|------|-----------------|
| 注文 | Order | ユーザーが商品を購入する行為を表すエンティティ | 注文管理 |
| 注文 | PurchaseRequest | 社内承認フローにおける購買申請 | 購買管理 |

---

### 2. データモデル（ER図 / クラス図）

要求を実現するために必要なデータ構造を定義してください。

* Mermaidの `erDiagram` または `classDiagram` を使用
* 主要な属性（カラム）とリレーションシップ（1対多など）を明記
* 以下の観点を含めること:
  - **集約ルート（Aggregate Root）** の特定
  - **エンティティ** と **値オブジェクト（Value Object）** の区別
  - **ドメインサービス** と **アプリケーションサービス** の責務分離方針
  - 論理削除 / 物理削除のポリシー
  - 監査フィールド（created_at, updated_at, created_by, updated_by）
  - 正規化レベル（第3正規形を基本とし、パフォーマンス上の理由で非正規化する箇所は根拠を明記）
  - インデックス戦略（検索パターンとの対応、インデックスタイプ: B-tree/GIN/Hash等、UNIQUE制約）
  - パーティショニング戦略（大量データが見込まれるテーブルの場合: Range/Hash/List）

---

### 3. 業務フローと状態遷移

ユーザーのアクションによるシステムの状態変化や処理フローを可視化してください。

* Mermaidの `sequenceDiagram`（処理の流れ）または `stateDiagram`（ステータスの変化）を使用
* 以下のフローを網羅すること:
  - **正常系（Happy Path）**
  - **異常系（エラー時）** — バリデーションエラー、外部サービス障害、タイムアウト
  - **補償/ロールバックフロー** — 処理途中で失敗した場合の復旧手順
  - **並行処理・競合状態** — 同じリソースへの同時アクセス時の振る舞い
* ドメインイベント（Domain Event）が発生する箇所を明示

---

### 4. トランザクション・整合性設計

各ユースケースのトランザクション境界と整合性担保方針を定義してください。

* **トランザクション境界**: 各ユースケースごとのトランザクションスコープ
* **集約をまたぐ整合性パターン**: Saga / TCC / Outboxパターン等の選定と根拠
* **ロック戦略**: 楽観的ロック / 悲観的ロックの使い分け方針
* **冪等性の担保方法**: 冪等性キーの生成・保管戦略
* **リトライ戦略**: 指数バックオフ、最大リトライ回数、Dead Letter Queue方針

---

### 5. API / インターフェース定義案

フロントエンドとバックエンド、あるいはシステム間で必要なインターフェースをリストアップしてください。

各エンドポイントについて以下を記述:

* **エンドポイント**: HTTPメソッド + パス（例: `POST /api/v1/orders`）
* **認証・認可要件**: 必要な認証方式、必要な権限/ロール
* **入力パラメータ**: 必須/任意、型、バリデーションルール
* **レスポンス**: 成功時（200/201等）のJSON構造
* **エラーレスポンス**: 各HTTPステータスコード別のエラーレスポンスボディ
  ```json
  {
    "error": {
      "code": "ORDER_STOCK_INSUFFICIENT",
      "message": "在庫が不足しています",
      "details": [...]
    }
  }
  ```
* **ページネーション戦略**: カーソルベース / オフセットベース（該当するAPIのみ）
* **冪等性**: 冪等性キーの要否（更新・作成系APIの場合）
* **レート制限**: エンドポイントごとの制限値の提案
* **APIバージョニング方針**: パス/ヘッダーのどちらで管理するか
* **セキュリティヘッダー**: CORSポリシー、CSP、CSRF対策、HSTS等の方針

---

### 6. サービス間通信設計（該当する場合）

マイクロサービスや外部サービスとの通信が発生する場合に記述してください。

* 各サービス間通信の方式（同期: REST/gRPC、非同期: Kafka/SQS/Pub-Sub）と選定理由
* イベントスキーマ定義（イベント名、ペイロード構造、バージョニング）
* メッセージの順序保証・重複排除方針
* サーキットブレーカー・リトライ・タイムアウトの設定値
* Dead Letter Queueの運用方針

※ モノリシックアーキテクチャの場合は「該当なし」と記載して省略可。

---

### 7. 実装上の懸念点・未決事項

エンジニアが実装するにあたり、現状の要求仕様では情報が不足している点や技術的リスクを、
カテゴリ別に整理してください。

**質問は非技術者が回答できる平易な表現で記述すること。**

| カテゴリ | 懸念点 | 影響度 | 推奨アクション |
|----------|--------|--------|---------------|
| 機能仕様の曖昧さ | [具体的な不明点] | High/Medium/Low | [平易な質問と確認先] |
| 技術的リスク | [具体的なリスク] | High/Medium/Low | [緩和策とビジネス上の影響] |
| パフォーマンス | [具体的な懸念] | High/Medium/Low | [対策案] |
| セキュリティ | [具体的な懸念] | High/Medium/Low | [対策案] |

---

### 8. 非機能要件

ドキュメントの要求から推測される非機能要件を整理してください。
明記がない場合は、一般的なベストプラクティスに基づいて推奨値を提案し `[推論補完]` と注記してください。

#### 8.1 パフォーマンス要件
* レスポンスタイム目標（API: p50 / p95 / p99）
* スループット要件（同時リクエスト数、TPS）
* データ量の成長見込みと対応方針

#### 8.2 スケーラビリティ
* 水平/垂直スケーリング方針
* ボトルネックになりうる箇所の特定

#### 8.3 脅威モデリングとセキュリティ要件

##### 脅威分析
* 信頼境界（Trust Boundary）の特定
* 攻撃面（Attack Surface）の特定とリスク評価

##### 認証・認可設計
* 認証方式の選定と根拠（OAuth2.0フロー種別 / JWT / Session等）
* トークン管理: アクセストークンTTL、リフレッシュトークン戦略
* セッション管理: 固定化防止、タイムアウト、同時セッション制御
* 認可方式: RBAC / ABACの選定、権限の粒度設計

##### データ暗号化
* 通信時暗号化: TLSバージョン要件（最低TLS 1.2）
* 保存時暗号化: アルゴリズム選定（AES-256-GCM等）、データ分類別暗号化ポリシー
* 鍵管理: KMS利用方針、ローテーション周期
* シークレット管理: シークレットストア選定、環境別分離方針、ソースコード混入防止策

##### OWASP Top 10対応方針
* A01 アクセス制御: 最小権限原則、デフォルトDeny設計
* A02 暗号化の失敗: 暗号化アルゴリズム選定、鍵管理方針
* A03 インジェクション: パラメータ化クエリ、ORM使用方針
* A06 脆弱なコンポーネント: 依存関係の脆弱性スキャン方針（SCA: Dependabot/Snyk等）
* A07 認証の失敗: MFA、パスワードポリシー
* A10 SSRF: アウトバウンドリクエスト制限方針

#### 8.4 データプライバシー・コンプライアンス
* 適用される規制の特定（GDPR / 個人情報保護法 / PCI DSS等）
* 個人情報に該当するデータの特定
* データ保持期間とパージ方針
* データ主体の権利への対応設計（アクセス権、訂正権、消去権、ポータビリティ権）
* 同意管理の必要性

#### 8.5 キャッシュ戦略
* キャッシュ対象データの特定
* TTL（Time To Live）設計
* キャッシュ無効化戦略（Write-Through / Write-Behind / Cache-Aside）
* 運用考慮: キャッシュヒット率目標、Eviction Policy、障害時フォールバック、ウォームアップ戦略

#### 8.6 可観測性（Observability）とSLI/SLO

##### SLI/SLO定義
* サービスレベル指標（SLI）: リクエスト成功率、レイテンシp99等
* サービスレベル目標（SLO）: 数値設定（例: 99.9% availability, p99 < 500ms）
* エラーバジェットの運用方針

##### ロギング
* 構造化ログフォーマット定義（必須フィールド: timestamp, level, service, trace_id, message）
* ログレベル設計（ERROR/WARN/INFO/DEBUGの使い分け基準）
* ログ保持期間とローテーション方針

##### メトリクス
* RED metrics（Rate, Error rate, Duration）の定義
* ビジネスメトリクス（注文数/s、売上/時間帯等）

##### セキュリティ監査ログ
* 記録対象イベント: 認証（成功/失敗）、認可変更、データアクセス、管理操作
* 記録項目: Who / What / When / Where / Result
* ログの保護: 改ざん防止策、保存期間（法規制準拠）

##### アラート
* アラート条件と閾値（例: "API p99 > 500ms が5分間継続 → #oncall に通知"）
* エスカレーションルール

##### 分散トレーシング
* トレーシングの必要性判定とスパン設計

#### 8.7 可用性・災害復旧
* RTO（目標復旧時間）/ RPO（目標復旧地点）の定義
* バックアップ方式と頻度
* リストアテスト方針

#### 8.8 インシデントレスポンス設計
* 緊急対応機構: アカウントロック、API緊急停止、IP遮断の技術的実装方針
* フォレンジック対応: 証拠保全のためのログ・データ保持方針
* データ漏洩時の通知フロー設計（法定通知期限への対応）

#### 8.9 コスト見積もり（該当する場合）
* 主要クラウドリソースの月額概算（コンピュート、DB、ストレージ）
* スケーリング時のコスト増加見込み
* コスト監視とアラートの方針

---

### 9. マイグレーション・ロールバック計画

#### 9.1 データベースマイグレーション
* スキーマ変更手順とゼロダウンタイム対応パターン（Expand-Contract等）
* 破壊的変更（カラム削除、型変更）の段階的実行手順
* データ移行が必要な場合の手順（バッチサイズ、進捗監視、整合性検証）
* ロールバック手順と自動ロールバックのトリガー条件

#### 9.2 デプロイメント戦略
* デプロイ方式の選定と根拠（Blue-Green / Canary / Rolling / Feature Flag）
* 既存APIとの後方互換性の評価
* 切り戻し判断基準

---

### 10. 依存関係分析

* **外部サービス/API** への依存とフォールバック方針（サーキットブレーカー等）
* **サードパーティライブラリ** の必要性と選定基準
* **サプライチェーンセキュリティ**: 依存関係の脆弱性スキャン方針、ライセンスコンプライアンス、バージョン固定戦略
* **他チーム/他モジュール** との依存関係（API提供待ち、共有DB等）
* 依存関係のリスク評価（SPOFの特定）

---

### 11. テスト戦略

#### 11.1 テストレベル別の方針
* **ユニットテスト**: ビジネスロジック、バリデーション、境界値（データモデルの各属性の型制約から導出）
* **統合テスト**: API結合、DB操作、外部サービス連携
* **E2Eテスト**: 主要なユーザーシナリオ
* **セキュリティテスト**: SAST/DAST/SCA/認証認可テスト
* **非機能テスト**: 負荷テストシナリオ案、パフォーマンス目標値

#### 11.2 テスト環境・インフラ
* テスト実行に必要な環境構成（ローカル / CI / ステージング）
* 外部サービス依存のモック戦略（Wiremock / testcontainers等）

#### 11.3 テストデータ
* 必要なテストデータとその生成方針
* テストデータにおける個人情報の取り扱い（匿名化/マスキング/合成データ方針）

#### 11.4 テスト自動化・カバレッジ
* 自動化対象の選定基準とCI/CD統合方針
* カバレッジ目標の提案（ライン/ブランチカバレッジ）

#### 11.5 回帰テスト
* 既存機能への影響範囲の特定
* 回帰テストスイートの更新方針

---

### 12. アクセシビリティ・国際化（該当する場合）

* WCAG準拠レベルの推奨
* 多言語対応が必要な箇所の特定
* 日付・通貨・数値フォーマットの考慮事項
* タイムゾーン処理の方針

※ UIが関わらないバックエンド専用の場合は「該当なし」と記載して省略可。

---

### 13. アーキテクチャ判断記録（ADR）

重要な技術的判断について、以下の形式で記録してください。
設計書内で判断が必要になった箇所（技術選択、パターン選定等）ごとに1つずつ作成。

| 項目 | 内容 |
|------|------|
| **判断事項** | [何を決めたか] |
| **背景** | [なぜその判断が必要だったか] |
| **選択肢** | [検討した選択肢とそれぞれのPros/Cons] |
| **決定** | [何を選んだか] |
| **理由** | [なぜそれを選んだか] |
| **影響** | [この判断によって生じる制約や影響] |
```

---

## オプション: マルチパースペクティブ評価

上記で生成された技術設計書を、以下の5つの視点でセルフレビューしてください。

```
上記の技術設計書を、以下の5つの専門家の視点でレビューし、
各視点ごとに Good（良い点）/ Concern（懸念点）/ Missing（不足）を指摘してください。

1. **シニアバックエンドエンジニア**: データモデルの完全性、API設計の実装可能性、トランザクション設計の妥当性
2. **QAエンジニア**: テスト戦略の網羅性、テスト環境の十分性、回帰テスト計画の妥当性
3. **プロダクトマネージャー**: ビジネス要求との整合性、未決事項の回答しやすさ、ビジネス価値の明確さ
4. **セキュリティエンジニア**: 脅威モデリングの網羅性、OWASP Top 10対応、暗号化・鍵管理の具体性
5. **DevOps/SREエンジニア**: SLI/SLO定義の実用性、マイグレーション計画の現実性、可観測性の具体性
```

---

## 次のステップ

この技術設計書をレビュー・確定した後、[technical-design-to-pbi-prompt.md](technical-design-to-pbi-prompt.md) を使用して
PBI（Product Backlog Item）/ GitHub Issue に分割できます。
